= Typescript Workshop
:toc:
:toclevels: 1
:sectnums:
:imagesdir: images

These are notes and code snippets from the Udemy Workshop https://www.udemy.com/course/understanding-typescript/[Understanding TypeScript]. Although this repository here uses code snippets from the Udemy Workshop, the original course is very much recommended.

== Introduction
* = superset of Java Script, which is a new statically, strongly-typed programming language on top of Java Script
* doesn't run in the browser, has to be compiled - that's what the CLI is for!
* type can either be stated explicitly:

    serverId:number = 10;

* type can also be omitted and chosen automatically:

    serverId = 10;

* with Ctrl + B, variables reveal their types:

image::typeCheckingWithCtrlB.png[]

* ES6 also brings types, but not yet supported by all browsers

== Installation
. https://www.npmjs.com/get-npm[install NPM]
. install TypeScript via

[source, terminal]
----
npm -g install typescript
----

== Compile TypeScript to JavaScript
. navigate to where your ts file is located
. compile with filename without ".ts", so for example to compile _script.ts_, do:

[source, terminal]
----
tsc script
----

== Setup for this workshop
* put project folder under control of NPM:
[source, terminal]
----
npm init
----
* will create a package.json
* install lite-server:
[source, terminal]
----
npm install lite-server --save-dev
----
* add script to start server (in _package.json_):
[source, terminal]
----
"scripts": {
    ...
    "start": "lite-server"
----
* start server with
[source, terminal]
----
npm start
----
* server will automatically react on changes in the codebase
* application on localhost:3000
* make folder managed by TypeScript with
[source, terminal]
----
tsc --init
----
* will create a _tsconfig.json_-file
* that way, all TypeScript files will be compiled with only
[source, terminal]
----
tsc
----
* attention: keep lite-server running in different terminal-tab!

== Types
[source, javascript]
----
// implicit declaration:
let myString = 'myString';   // implicit string
//myString = 42;             // error!

let myNumber = 42;           // implicit number
//myNumber = 'anyString';    // error!

let myBoolean = true;        // implicit boolean
//myBoolean = 1;             //error, despite the fact that "1" could be interpreted as "true"

let myVariable;              // type = 'any', from JavaScript
myVariable = 12;             // OK
myVariable = '12';           // OK because 'any' gets overridden

// explizit declaration:
let myExplicitNumber: number;
myExplicitNumber = 12;       // OK
myExplicitNumber = '12';     // error!

let myArray = ["bla", "blubber"];
console.log(typeof myArray);        // prints "object"; however: TypeScript only allows strings in this array ...
myArray = [42];              // ... this will cause an error
myArray = ["42"];            // OK

let myArray: string[] = ["bla", "blubber"];     // explicit array of strings

// tuples = new type in TypeScript (not available in JavaScript)
let address: [string, number] = ["aString", 42];

// enum
enum Color {
    Red,
    Green,
    Blue
}
let myColor: Color = Color.Red;

// Internally represented as number (0-based). Can be configured differently:
enum Color {
    Red = 42,
    Green = 43,
    Blue = 44
}

// any => use only in exceptional cases!
let blubber: any = "aString";
blubber = 42;           // OK

//functions
function getSomeString(): string {
    return "some string";
}

function noReturnValue(): void {
    //return "some string";       // error because no return expected
}

// argument types
function myFunction(v1: number, v2: number): number {
    return v1 + v2;
}

// function types
let myFunctionAsAVariable: (val1: number, val2: number) => number;
myFunctionAsAVariable = myFunction;
myFunctionAsAVariable(1, 2);

 let myFunctionAsAVariable2: () => void;
 myFunctionAsAVariable2 = noReturnValue;

// objects
let myData = {
    aString: "myString",
    aNumber: 42
};

myData = {};
// error: "not assignable" because TypeScript automatically assigned a type with the two attributes (aString and aNumber)

myData = {
    anotherString: "myString",
    anotherNumber: 42
};
// error: names don't match!

let myData: {aString: string, aNumber: number} = {
    aString: "myString",
    aNumber: 42
};

// type alias
// = storing a type; alternative  to class
type MyType = {aString: string, aNumber: number};
let x: MyType = {
    aString: "blubber",
    aNumber: 12
}

// union types
// sometimes more than one type should be appliable, but not just "any"
let someUncertainInput: any = 12;
someUncertainInput = "12"           // OK
someUncertainInput = false          // OK, but only number or strings should work

let someUncertainInput2: number | string = 12;
someUncertainInput2 = "12"           // OK
//someUncertainInput2 = false          // error

// check types
let value = "a string";
if(typeof value == "string") {
    // ...
}

// new types (since TypeScript 2.0)
// 1. "never", when a function never returns:
function neverReturns(): never {
    throw new Error("blubber");
}

// 2. nullable types:
let canBeNull = 12;
canBeNull = null;       // OK

// in tsConfig.json:
// "strictNullChecks": true

let canBeNull = 12;
canBeNull = null;
// error: 'null' is not assignable to type 'number' because canBeNull was initialized to be a (not-nullable) number

let canBeNull: number | null = 12;
canBeNull = null;       // OK again

----

== TypeScript Compiler
=== Types
* types are removed in JavaScript!
* default behavior of TypeScript compiler: compile to JavaScript, even when there are errors
* compiling despite errors can be disabled in _tsconfig.json_ with
[source, properties]
----
"noEmitOnError": true
----

=== SourceMaps
* mapping between TypeScript and JavaScript
* enable in _tsconfig.json_ with:
[source, properties]
----
"sourceMap": true
----
* with that, _app.js.map_ is created
* used by browser to enable debugging

=== noImplicitAny
[source, javascript]
----
let anything;       // will get type "any"
anything = 12;
----
* type of _any_ automatically assigned
* can be disabled in _tsconfig.json_ with:
[source, properties]
----
"noImplicitAny": true
----
* now, compiler will throw error for above code
* forces programmer to use proper types

== ES6
* TypeScript supports many features of ES6

=== let & const
* _var_ = global scope, around since JavaScript, don't use!
* _let_ = block-scoped = only visible inside block
* _const_ = constant, not changable

[source,javascript]
----
let myVariable = "blubber";
myVariable = "another blubber";     // OK

const anotherVariable = 100;
//anotherVariable = 200;              // error

function reset() {
    let myVariable = "blubber in function";
    console.log(myVariable);        // "blubber in function"
}
reset();
console.log(myVariable);            // "another blubber"
----

=== Arrow Functions
[source,javascript]
----
// normal function:
const addNumbers = function(number1: number, number2: number): number {
    return number1 + number2;
}

// arrow function short syntax:
const multiplyNumbers = (number1: number, number2: number) => number1 * number2;

// arrow function long syntax:
const multiplyNumbers = (number1: number, number2: number) => {
    // do something else here
    return number1 * number2;
}

// one argument:
const doStuff = myVariable => console.log(myVariable);

// without arguments:
const doLog = () => {
    console.out("log");
}
----

=== Default Parameters
[source,javascript]
----
const simpleFunction = (myParameter: number = 1): void => {
    console.out(myParameter);
}
simpleFunction(42);     // OK - will print 42
simpleFunction();       // OK - will print 1
----

=== Rest & Spread Operators
* same syntax ("_..._") for two different use cases:
** spread-operator used when function is called to spread out array
** rest-operator used in function signature to aggregate list of values to an array

[source,javascript]
----
const numbers = [1, 2, 3];
Math.max(4, 5, 6);      // OK
Math.max(numbers);      // error because no array allowed here

// spread-operator spreads the contents of the array into a list of values:
Math.max(...numbers);   // OK

// rest-parameter: function that gets list of numbers as parameters and returns an array:
function makeArray(...args: number) {
    return args;
}
makeArray(1, 2, 3);     // OK
----

* attention: in a function where some parameters that should NOT be combined and some that should be combined: combine-parameters have to be the last ones!
* since TypeScript 3, rest operator working also with tuples:

[source,javascript]
----
function foo(...myObject: [number, boolean]) {
    // ...
}
----

=== Destructuring
* instead of picking every single array element one by one, all elements can be extracted from an array:

[source,javascript]
----
const myArray = [1, 2, 3];
const [number1, number2, number3] = myArray;
----

* result:
** _number1_ is _1_,
** _number2_ is _2_,
** _number3_ is _3_
* works also for objects:

[source,javascript]
----
const myObject = {foo: "foo", bar: 42};
const {foo, bar} = myObject;
----

* result:
** _foo_ is "_foo_"
** _bar_ is _42_

* also possible: renaming variables:

[source,javascript]
----
const myObject = {foo: "foo", bar: 42};
const {foo2, bar2} = myObject;
----

* result:
** _foo_ is undefined
** _bar_ is undefined
** _foo2_ is "_foo_"
** _bar2_ is _42_

=== Template Literals
* = strings with more features
* created with _``_

[source,javascript]
----
const myString = "myString";
const message = `Here is a message.
It's multilined!
Here is another string: ${myString}.
`;
----

== Classes

* also possible to create classes in ES6, but with less features like private properties
* _private_ properties only accessible within the object; _protected_ attributes additionally accessible in every object that inherits this object

[source,javascript]
----
class Person {
    name: string;
    private type: string;
    protected age: number;

    constructor(name: string, public username: string) {
        this.name = name;
    }

   printAge() {
        console.log(this.age);
   }

   setType(type: string) {
        this.type = type;
   }
}

const person = new Person("Peter", "peter");
----

=== Inheritance
[source,javascript]
----
class Customer extends Person {

    constructor(username: string) {
        super("customer", username);        // super() necessary as first call in constructor!
        this.age = 42;                      // OK
        //this.type = "impossible!"           // error because "private"
    }
}

const customer = new Customer("myusername");
----

=== Getters and Setters

* setters look like methods, but are not methods in TypeScript

[source,javascript]
----
class MyClass {

    private myAttribute: string;

    set setMyAttribute(value: string) {
        this.myAttribute = value;
    }

    get getMyAttribute() {
        return this.myAttribute;
    }
}

let myClass = new MyClass();
console.log(myClass.getMyAttribute);        // getMyAttribute is not a function!
myClass.setMyAttribute = "foo";             // setter also not a function!
----

=== Static Properties and Methods
[source,javascript]
----
class Helpers {
    static PI: number = 3.14;
    static doStuff(): void {}
}

Helpers.PI;
Helpers.doStuff();
----

=== Abstract Classes
* can't be instantiated directly, only by inheriting them

[source,javascript]
----
abstract class MyAbstractClass {
    // ...
}
----

=== Readonly Properties
[source, javascript]
----
class MyClass {
    constructor(public readonly myProperty: string) {}
}

let myClass = new MyClass();
myClass.myProperty = "x";       // error
----

== Namespaces
* only make sense for small projects; use modules for bigger projects!

[source,javascript]
----
namesapce MyNamespace1 {
    const MYCONST = "blubber";

    export function blubberize(content: string): string {
        return content + MYCONST;
    }
}

console.log(MyNamespace1.blubberize("my string is "));
----

* important: functions in namespaces have to have an _export_ to be used outside of the namespace
* namespaces can extend over multiple files, just "declare" them in different files and import those files to the classes where they are used:

[source, javascript]
----
/// <reference path="myNamespace1.ts" />
/// <reference path="myFile2.ts" />

// normal code where you can use the new namespace:
console.log(MyNamespace1.blubberize("my string is "));
----

* also possible to have namespaces in namespaces

== Modules
* classes, functions and attributes with _export_ can be imported in other classes like this:

[source,javascript]
----
import { MYCONSTANT, myFunction } from "./myPath/myClassWithoutFileEnding";
----

* native JavaScript doesn' support module, hence module loader required (not contained in this course)
* also possible to use an alias:

[source,javascript]
----
import * as MyAlias from "./myPath/myClassWithoutFileEnding";
----

* above is a relative path, which will be resolved in local project
* absolute paths like this one will be resolved in _node_modules_ folder:

[source,javascript]
----
import { Component } from "@angular/core";
----


== Features

=== Automatic Creation of Properties
* instead of writing this:

[source]
----
export class Ingredient {
    public name: string;
    public amount: number;

    constructor(name: string, amount: number) {
      this.name = name;
      this.amount = amount;
    }
  }
----

* ... this can be written with the same result:
[source]
----
export class Ingredient {

  constructor(public name: string, public amount: number) {
  }
}
----
* properties will be automatically created and assigned with the parameters of the constructor

=== Variable Declaration: var, let, const
* three options for declaring variable: var, let, const

==== var
* spoiler alert: least preferable from the three options
* traditional the way to declare a variable in JavaScript
* available in TypeScript because TypeScript = superset of JavaScript
* some odd "features" like "var-scoping": declarations of var are accessible anywhere, even globally. Details see https://www.typescriptlang.org/docs/handbook/variable-declarations.html[here]

==== let
* introduced because of the problems with var
* block-scoped = not visible outside of the block let was defined in
* behavior = expected behavior when coming from Java

==== const
* = augmentation of let; prevents re-assignment
* principle of least privilege: const should be used whenever re-assignment of variable is not intended
