= Typescript Workshop
:toc:
:toclevels: 1
:sectnums:
:imagesdir: images

These are notes and code snippets from the Udemy Workshop https://www.udemy.com/course/understanding-typescript/[Understanding TypeScript]. Although this repository here uses code snippets from the Udemy Workshop, the original course is very much recommended.

== Introduction
* = superset of Java Script, which is a new statically, strongly-typed programming language on top of Java Script
* doesn't run in the browser, has to be compiled - that's what the CLI is for!
* type can either be stated explicitly:

    serverId:number = 10;

* type can also be omitted and chosen automatically:

    serverId = 10;

* with Ctrl + B, variables reveal their types:

image::typeCheckingWithCtrlB.png[]

* ES6 also brings types, but not yet supported by all browsers

== Installation
. https://www.npmjs.com/get-npm[install NPM]
. install TypeScript via

[source, terminal]
----
npm -g install typescript
----

== Compile TypeScript to JavaScript
. navigate to where your ts file is located
. compile with filename without ".ts", so for example to compile _script.ts_, do:

[source, terminal]
----
tsc script
----

== Setup for this workshop
* put project folder under control of NPM:
[source, terminal]
----
npm init
----
* will create a package.json
* install lite-server:
[source, terminal]
----
npm install lite-server --save-dev
----
* add script to start server (in _package.json_):
[source, terminal]
----
"scripts": {
    ...
    "start": "lite-server"
----
* start server with
[source, terminal]
----
npm start
----
* server will automatically react on changes in the codebase
* application on localhost:3000
* make folder managed by TypeScript with
[source, terminal]
----
tsc --init
----
* will create a _tsconfig.json_-file
* that way, all TypeScript files will be compiled with only
[source, terminal]
----
tsc
----
* attention: keep lite-server running in different terminal-tab!

== Types
[source, javascript]
----
// implicit declaration:
let myString = 'myString';   // implicit string
//myString = 42;             // error!

let myNumber = 42;           // implicit number
//myNumber = 'anyString';    // error!

let myBoolean = true;        // implicit boolean
//myBoolean = 1;             //error, despite the fact that "1" could be interpreted as "true"

let myVariable;              // type = 'any', from JavaScript
myVariable = 12;             // OK
myVariable = '12';           // OK because 'any' gets overridden

// explizit declaration:
let myExplicitNumber: number;
myExplicitNumber = 12;       // OK
myExplicitNumber = '12';     // error!

let myArray = ["bla", "blubber"];
console.log(typeof myArray);        // prints "object"; however: TypeScript only allows strings in this array ...
myArray = [42];              // ... this will cause an error
myArray = ["42"];            // OK

let myArray: string[] = ["bla", "blubber"];     // explicit array of strings

// tuples = new type in TypeScript (not available in JavaScript)
let address: [string, number] = ["aString", 42];

// enum
enum Color {
    Red,
    Green,
    Blue
}
let myColor: Color = Color.Red;

// Internally represented as number (0-based). Can be configured differently:
enum Color {
    Red = 42,
    Green = 43,
    Blue = 44
}

// any => use only in exceptional cases!
let blubber: any = "aString";
blubber = 42;           // OK

//functions
function getSomeString(): string {
    return "some string";
}

function noReturnValue(): void {
    //return "some string";       // error because no return expected
}

// argument types
function myFunction(v1: number, v2: number): number {
    return v1 + v2;
}

// function types
let myFunctionAsAVariable: (val1: number, val2: number) => number;
myFunctionAsAVariable = myFunction;
myFunctionAsAVariable(1, 2);

 let myFunctionAsAVariable2: () => void;
 myFunctionAsAVariable2 = noReturnValue;

// objects
let myData = {
    aString: "myString",
    aNumber: 42
};

myData = {};
// error: "not assignable" because TypeScript automatically assigned a type with the two attributes (aString and aNumber)

myData = {
    anotherString: "myString",
    anotherNumber: 42
};
// error: names don't match!

let myData: {aString: string, aNumber: number} = {
    aString: "myString",
    aNumber: 42
};

// type alias
// = storing a type; alternative  to class
type MyType = {aString: string, aNumber: number};
let x: MyType = {
    aString: "blubber",
    aNumber: 12
}

// union types
// sometimes more than one type should be appliable, but not just "any"
let someUncertainInput: any = 12;
someUncertainInput = "12"           // OK
someUncertainInput = false          // OK, but only number or strings should work

let someUncertainInput2: number | string = 12;
someUncertainInput2 = "12"           // OK
//someUncertainInput2 = false          // error

// check types
let value = "a string";
if(typeof value == "string") {
    // ...
}

// new types (since TypeScript 2.0)
// 1. "never", when a function never returns:
function neverReturns(): never {
    throw new Error("blubber");
}

// 2. nullable types:
let canBeNull = 12;
canBeNull = null;       // OK

// in tsConfig.json:
// "strictNullChecks": true

let canBeNull = 12;
canBeNull = null;
// error: 'null' is not assignable to type 'number' because canBeNull was initialized to be a (not-nullable) number

let canBeNull: number | null = 12;
canBeNull = null;       // OK again

----

== TypeScript Compiler
=== Types
* types are removed in JavaScript!
* default behavior of TypeScript compiler: compile to JavaScript, even when there are errors
* compiling despite errors can be disabled in _tsconfig.json_ with
[source, properties]
----
"noEmitOnError": true
----

=== SourceMaps
* mapping between TypeScript and JavaScript
* enable in _tsconfig.json_ with:
[source, properties]
----
"sourceMap": true
----
* with that, _app.js.map_ is created
* used by browser to enable debugging

=== noImplicitAny
[source, javascript]
----
let anything;       // will get type "any"
anything = 12;
----
* type of _any_ automatically assigned
* can be disabled in _tsconfig.json_ with:
[source, properties]
----
"noImplicitAny": true
----
* now, compiler will throw error for above code
* forces programmer to use proper types

== Features

=== Automatic Creation of Properties
* instead of writing this:

[source]
----
export class Ingredient {
    public name: string;
    public amount: number;

    constructor(name: string, amount: number) {
      this.name = name;
      this.amount = amount;
    }
  }
----

* ... this can be written with the same result:
[source]
----
export class Ingredient {

  constructor(public name: string, public amount: number) {
  }
}
----
* properties will be automatically created and assigned with the parameters of the constructor

=== Variable Declaration: var, let, const
* three options for declaring variable: var, let, const

==== var
* spoiler alert: least preferable from the three options
* traditional the way to declare a variable in JavaScript
* available in TypeScript because TypeScript = superset of JavaScript
* some odd "features" like "var-scoping": declarations of var are accessible anywhere, even globally. Details see https://www.typescriptlang.org/docs/handbook/variable-declarations.html[here]

==== let
* introduced because of the problems with var
* block-scoped = not visible outside of the block let was defined in
* behavior = expected behavior when coming from Java

==== const
* = augmentation of let; prevents re-assignment
* principle of least privilege: const should be used whenever re-assignment of variable is not intended
